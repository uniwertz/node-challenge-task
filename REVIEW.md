## Обзор

Этот документ фиксирует выявленные антипаттерны, баги и архитектурные недостатки в проекте `token-price-service` (путь: `/Users/den/apps/test/node`), а также содержит предложения по улучшениям с обоснованием.

### Охваченные файлы
- `src/main.ts`
- `src/app.module.ts`
- `src/services/token-price-update.service.ts`
- `src/services/mock-price.service.ts`
- `src/kafka/kafka-producer.service.ts`
- `src/models/token.entity.ts`
- `src/models/token.schema.ts`
- `src/models/token-price-update-message.ts`
- `tsconfig.json`, `package.json`

---

## 1. Выявление проблем

### 1.1 Антипаттерны и потенциальные баги
- **Жёстко зашитая конфигурация (DB, Kafka, порт)**
  - В `src/app.module.ts` настройки TypeORM (host, port, user, password, database) заданы константами. В `src/kafka/kafka-producer.service.ts` брокеры Kafka и `clientId` также хардкодятся. В `src/main.ts` порт 3000 не конфигурируется.
  - Риск: несовместимость окружений, невозможность безопасного деплоя, утечки секретов.

- **Побочные эффекты в конструкторах и на старте модуля**
  - `KafkaProducerService`: вызов `this.connect()` в конструкторе (асинхронный побочный эффект без ожидания).
  - `AppModule.onModuleInit`: сидинг БД и запуск фонового сервиса обновления цен прямо из модуля.
  - Риск: гонки инициализации, неочевидный порядок старта, трудности тестирования.

- **Неполноценная обработка ошибок и завершение процесса**
  - `src/main.ts`: при ошибке старта просто логируется `error.message`, процесс не завершается с ненулевым кодом; не включены shutdown hooks.
  - `KafkaProducerService.sendPriceUpdateMessage`: нет `await` у `producer.send`, ошибки могут теряться, подтверждения отправки нет.
  - Риск: сервис в «полу-рабочем» состоянии, потеря сообщений, сложность инцидент-менеджмента.

- **Несоответствие типов для денежных значений (decimal vs number)**
  - `Token.price` хранится в PostgreSQL как `decimal(28,0)`, но в коде используется как `number`. TypeORM в Postgres, как правило, возвращает `string` для `decimal`, что приведёт к:
    - сравнение `oldPrice !== newPrice` всегда `true` из-за несоответствия типов (`string` vs `number`), что вызывает лишние отправки в Kafka и записи в БД;
    - потенциальные ошибки округления.

- **Дублирование и денормализация данных в сущности**
  - В `src/models/token.entity.ts` одновременно есть `chainId` и `chain_Id`, а также блоки `chain_*` и `logo_*` полей. Это явная денормализация и несогласованность нейминга (`camelCase`/`snake_Case`/смешение регистра).
  - Риск: расхождения данных, усложнение миграций и эволюции схемы, рост связности.

- **Несогласованность схем валидации (Zod) с сущностью**
  - `token.schema.ts` повторяет денормализованные поля и задаёт `price` как `number`, что расходится с БД (`decimal`).
  - `address: z.instanceof(Buffer)` ограничивает источники данных; часто адрес приходит как строка/hex в DTO.

- **Фоновый цикл через `setInterval` с async-колбэком**
  - `TokenPriceUpdateService`: `setInterval` с async функцией, где ошибки внутри ловятся, но очереди вызовов могут наслаиваться, если выполнение дольше интервала. Отсутствует ограничение конкуренции/«шторка» выполнения.
  - Нет конфигурируемости интервала из окружения; начальный запуск из `onModuleInit` скрещён с сидингом.

- **Логи и стиль**
  - Местами используется `console.error` вместо Nest `Logger`.
  - Нет глобальных `ValidationPipe`, `Config`-валидации и health-check.

- **Нестрогая компиляция TypeScript**
  - `tsconfig.json`: отключены многие строгие флаги (`strictNullChecks`, `noImplicitAny`, `forceConsistentCasingInFileNames`, и пр.). Риск пропуска классов ошибок на этапе компиляции.

### 1.2 Конкретные примеры багов
- **Потеря await при отправке в Kafka**
  - В `KafkaProducerService.sendPriceUpdateMessage` нет `await this.producer.send(...)`, из-за чего код продолжает выполнение, не дожидаясь подтверждения отправки.

- **Гонки соединения с Kafka**
  - `connect()` вызывается в конструкторе и не awaited перед первой отправкой. Возможна попытка отправить сообщения до установления соединения.

- **Неверное сравнение цен (типовая несовместимость)**
  - `oldPrice !== newPrice` при `oldPrice` как `string` и `newPrice` как `number` приведёт к ложным обновлениям.

- **Жёстко зашитые учётные данные БД**
  - Риск утечек и несовместимости с деплой-процессами.

---

## 2. Предложенные изменения и обоснование

### 2.1 Управление конфигурацией
- **Что сделать**: вынести параметры БД, Kafka, интервал обновления и порт сервера в `@nestjs/config`; добавить схему валидации конфигурации (например, `zod`/`Joi`).
- **Зачем**: единообразное управление окружениями, безопасность секретов, предотвращение конфигурационных ошибок при старте.

### 2.2 Жизненный цикл приложения
- **Что сделать**:
  - Перенести асинхронное подключение Kafka из конструктора в `onModuleInit` и явно `await`.
  - В `main.ts` включить `app.enableShutdownHooks()` и корректное завершение при ошибках (`process.exit(1)`); добавить глобальные `ValidationPipe`.
  - Разделить сидинг данных и запуск фонового процесса: сидинг запускать отдельной командой или guard’ить по флагу окружения.
- **Зачем**: предсказуемая инициализация, корректное завершение, управляемость прод-циклов.

### 2.3 Kafka-производитель
- **Что сделать**:
  - Делать `await producer.send(...)` и обрабатывать ошибки с ретраями/backoff.
  - Параметризовать `topic`, `clientId`, `brokers` через конфиг.
  - Рассмотреть подтверждения доставки, метрики и DLQ/повторные попытки на уровне потребителей.
- **Зачем**: избежать потери сообщений и гонок соединения, повысить наблюдаемость.

### 2.4 Модель данных `Token`
- **Что сделать**:
  - Устранить дублирование `chainId`/`chain_Id`; унифицировать нейминг (camelCase на уровне кода, snake_case в БД через `name`); вынести `chain_*` и `logo_*` в связанные таблицы (нормализация) или обосновать денормализацию с инвариантами.
  - Для `price (decimal)` использовать безопасное представление: хранить и оперировать как `string` или внедрить `ValueTransformer`/библиотеку big number.
- **Зачем**: целостность данных, корректность денежных расчётов, упрощение эволюции схемы.

### 2.5 Схемы валидации (Zod)
- **Что сделать**:
  - Привести `token.schema.ts` в соответствие с сущностью после нормализации.
  - Разрешить ввод адреса в человеко-ориентированном формате (строка/hex) и конвертировать в `Buffer` в слое маппинга.
  - Для денежных полей — валидировать строковое представление или использовать branded types.
- **Зачем**: единая контрактная модель, надёжная валидация входных данных.

### 2.6 Фоновый сервис обновления цен
- **Что сделать**:
  - Перейти на `@nestjs/schedule` (`Cron` / `Interval`) с взаимным исключением выполнения (mutex/«шторка») или использовать простую защиту: не запускать новый цикл, пока предыдущий не завершён.
  - Сделать интервал конфигурируемым; опционально — обрабатывать токены батчами или с ограничением параллелизма.
  - Перенести запуск сервиса из `AppModule.onModuleInit` в отдельный orchestrator или оставлять явный вызов при старте приложения (но не смешивать с сидингом).
- **Зачем**: предсказуемое выполнение без накопления конкурирующих задач, управляемая нагрузка на БД и Kafka.

### 2.7 main.ts и кросс-срезовые аспекты
- **Что сделать**: добавить глобальные пайпы/фильтры, health-check (например, эндпойнт `/health`), структурированные логи.
- **Зачем**: операбельность, наблюдаемость, защита от невалидных входных данных.

### 2.8 TypeScript строгий режим
- **Что сделать**: включить `strict` и связанные флаги (`noImplicitAny`, `strictNullChecks`, `forceConsistentCasingInFileNames` и др.).
- **Зачем**: ловить классы ошибок на этапе сборки, повысить качество кода.

---

## 3. Краткая карта: Проблема → Изменение → Обоснование

- **Хардкод конфигурации** → Вынести в `@nestjs/config` + схема валидации → Надёжность окружений, безопасность.
- **Побочные эффекты в конструкторах** → Перенос в `onModuleInit`/lifecycle и `await` → Предсказуемая инициализация.
- **Kafka без await и ретраев** → `await send` + обработка ошибок/ретраи → Гарантированная отправка/видимость сбоев.
- **`decimal` как `number`** → Строка/BigNumber/трансформер → Корректные сравнения и отсутствие лишних апдейтов.
- **Денормализация и несогласованные имена** → Нормализация + единый стиль имён → Целостность и сопровождаемость.
- **Async в `setInterval` без шторки** → `@nestjs/schedule` + защита от конкурентного запуска → Стабильность фоновых задач.
- **Отсутствие глобальной валидации/health** → `ValidationPipe`, health-check → Операбельность, безопасность.
- **Нестрогий TS** → Включить strict-флаги → Раннее обнаружение ошибок.

---

## 4. Приоритеты внедрения
1) Безопасность и надёжность: конфигурация, корректная инициализация Kafka, строгий TS.
2) Корректность домена: приведение `price` к безопасному типу, устранение дублирования полей.
3) Операционные аспекты: health-check, валидация конфигурации, structured logging.
4) Производительность и масштабирование: шедулер, батчи/параллелизм с лимитами.

---

## 5. Потенциальные риски и миграции
- Нормализация сущности потребует миграций БД и возможной адаптации потребителей Kafka.
- Изменение представления `price` потребует адаптации мест, где ожидается `number`.
- Вынесение сидера из `onModuleInit` изменит стартовый сценарий — потребуется обновление README/скриптов.
