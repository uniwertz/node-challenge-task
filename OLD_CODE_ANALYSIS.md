# Token Price Service (OLD)

Этот документ фиксирует выявленные антипаттерны, баги и архитектурные недостатки в проекте `token-price-service`, а также содержит предложения по улучшениям с обоснованием.

### Охваченные файлы
- `src/main.ts`
- `src/app.module.ts`
- `src/services/token-price-update.service.ts`
- `src/services/mock-price.service.ts`
- `src/kafka/kafka-producer.service.ts`
- `src/models/token.entity.ts`
- `src/models/token.schema.ts`
- `src/models/token-price-update-message.ts`
- `tsconfig.json`, `package.json`

---

## 1. Выявление проблем

### 1.1 Антипаттерны и потенциальные баги
- **Жёстко зашитая конфигурация (DB, Kafka, порт)**
  - В `src/app.module.ts` настройки TypeORM (host, port, user, password, database) заданы константами. В `src/kafka/kafka-producer.service.ts` брокеры Kafka и `clientId` также хардкодятся. В `src/main.ts` порт 3000 не конфигурируется.
  - Риск: несовместимость окружений, невозможность безопасного деплоя, утечки секретов.

- **Побочные эффекты в конструкторах и на старте модуля**
  - `KafkaProducerService`: вызов `this.connect()` в конструкторе (асинхронный побочный эффект без ожидания).
  - `AppModule.onModuleInit`: сидинг БД и запуск фонового сервиса обновления цен прямо из модуля.
  - Риск: гонки инициализации, неочевидный порядок старта, трудности тестирования.

- **Неполноценная обработка ошибок и завершение процесса**
  - `src/main.ts`: при ошибке старта просто логируется `error.message`, процесс не завершается с ненулевым кодом; не включены shutdown hooks.
  - `KafkaProducerService.sendPriceUpdateMessage`: нет `await` у `producer.send`, ошибки могут теряться, подтверждения отправки нет.
  - Риск: сервис в «полу-рабочем» состоянии, потеря сообщений, сложность инцидент-менеджмента.

- **Несоответствие типов для денежных значений (decimal vs number)**
  - `Token.price` хранится в PostgreSQL как `decimal(28,0)`, но в коде используется как `number`. TypeORM в Postgres, как правило, возвращает `string` для `decimal`, что приведёт к:
    - сравнение `oldPrice !== newPrice` всегда `true` из-за несоответствия типов (`string` vs `number`), что вызывает лишние отправки в Kafka и записи в БД;
    - потенциальные ошибки округления.

- **Дублирование и денормализация данных в сущности**
  - В `src/models/token.entity.ts` одновременно есть `chainId` и `chain_Id`, а также блоки `chain_*` и `logo_*` полей. Это явная денормализация и несогласованность нейминга (`camelCase`/`snake_Case`/смешение регистра).
  - Риск: расхождения данных, усложнение миграций и эволюции схемы, рост связности.

- **Несогласованность схем валидации (Zod) с сущностью**
  - `token.schema.ts` повторяет денормализованные поля и задаёт `price` как `number`, что расходится с БД (`decimal`).
  - `address: z.instanceof(Buffer)` ограничивает источники данных; часто адрес приходит как строка/hex в DTO.

- **Фоновый цикл через `setInterval` с async-колбэком**
  - `TokenPriceUpdateService`: `setInterval` с async функцией, где ошибки внутри ловятся, но очереди вызовов могут наслаиваться, если выполнение дольше интервала. Отсутствует ограничение конкуренции/«шторка» выполнения.
  - Нет конфигурируемости интервала из окружения; начальный запуск из `onModuleInit` скрещён с сидингом.

- **Логи и стиль**
  - Местами используется `console.error` вместо Nest `Logger`.
  - Нет глобальных `ValidationPipe`, `Config`-валидации и health-check.

- **Нестрогая компиляция TypeScript**
  - `tsconfig.json`: отключены многие строгие флаги (`strictNullChecks`, `noImplicitAny`, `forceConsistentCasingInFileNames`, и пр.). Риск пропуска классов ошибок на этапе компиляции.

### 1.2 Конкретные примеры багов
- **Потеря await при отправке в Kafka**
  - В `KafkaProducerService.sendPriceUpdateMessage` нет `await this.producer.send(...)`, из-за чего код продолжает выполнение, не дожидаясь подтверждения отправки.

- **Гонки соединения с Kafka**
  - `connect()` вызывается в конструкторе и не awaited перед первой отправкой. Возможна попытка отправить сообщения до установления соединения.

- **Неверное сравнение цен (типовая несовместимость)**
  - `oldPrice !== newPrice` при `oldPrice` как `string` и `newPrice` как `number` приведёт к ложным обновлениям.

- **Жёстко зашитые учётные данные БД**
  - Риск утечек и несовместимости с деплой-процессами.

---

## 2. Предложенные изменения и обоснование

### 2.1 Управление конфигурацией
- **Что сделано**: параметры БД, Kafka, интервал обновления и порт сервера вынесены в `@nestjs/config`; добавлена схема валидации конфигурации (`zod`).
- **Зачем**: единообразное управление окружениями, безопасность секретов, предотвращение конфигурационных ошибок при старте.

### 2.2 Жизненный цикл приложения
- **Что сделано**:
  - Асинхронное подключение Kafka перенесено из конструктора в `onModuleInit` с явным `await`.
  - В `main.ts` включены `app.enableShutdownHooks()` и корректное завершение при ошибках (`process.exit(1)`); добавлены глобальные `ValidationPipe`.
  - Сидинг данных отделён от запуска фонового процесса: сидинг запускается отдельной командой либо управляется через флаг окружения.
- **Зачем**: предсказуемая инициализация, корректное завершение, управляемость прод-циклов.

### 2.3 Kafka-производитель
- **Что сделано**:
  - Добавлено `await producer.send(...)` и обработка ошибок с ретраями/backoff.
  - `topic`, `clientId`, `brokers` параметризованы через конфиг.
  - Добавлены подтверждения доставки/метрики; рассмотрены механизмы DLQ/повторных попыток на уровне потребителей.
- **Зачем**: избежать потери сообщений и гонок соединения, повысить наблюдаемость.

### 2.4 Модель данных `Token`
- **Что сделано**:
  - Устранено дублирование `chainId`/`chain_Id`; унифицирован нейминг (camelCase в коде, snake_case в БД через `name`); `chain_*` и `logo_*` вынесены в связанные таблицы (нормализация) либо денормализация формализована инвариантами.
  - Для `price` внедрён fixed‑point формат: `TokenPrice` хранит значение как `BigInt amount` при фиксированном масштабе `scale=8`; в БД используется `DECIMAL`, во внешнем API — строки. Арифметика и сравнения выполняются без float.
- **Зачем**: целостность данных, корректность денежных расчётов, отсутствие ошибок округления, совместимость с ончейн‑подходом (fixed‑point).

### 2.5 Схемы валидации (Zod)
- **Что сделано**:
  - `token.schema.ts` приведён в соответствие с сущностью после нормализации.
  - Разрешён ввод адреса в человеко-ориентированном формате (строка/hex) с преобразованием в `Buffer` в слое маппинга.
  - Для денежных полей реализована валидация строкового представления либо применены branded types.
- **Зачем**: единая контрактная модель, надёжная валидация входных данных.

### 2.6 Обновление цен
- **Что сделано**:
  - Отказались от `@nestjs/schedule`; обновление цен выполняется внешним планировщиком (Kubernetes CronJob). В приложении оставлен idempotent use‑case и триггер‑эндпоинт.
  - Обработка выполнена батчами, сэкономлены round‑trips к БД (batch save), ограничена параллельность.
- **Зачем**: надёжный и управляемый прод‑процесс (CRON на уровне кластера), предсказуемая нагрузка, простота эксплуатации.

### 2.7 main.ts и кросс-срезовые аспекты
- **Что сделано**: добавлены глобальные пайпы/фильтры, health-check (например, эндпойнт `/health`), структурированные логи.
- **Зачем**: операбельность, наблюдаемость, защита от невалидных входных данных.

### 2.8 TypeScript строгий режим
- **Что сделано**: включены `strict` и связанные флаги (`noImplicitAny`, `strictNullChecks`, `forceConsistentCasingInFileNames` и др.).
- **Зачем**: ловить классы ошибок на этапе сборки, повысить качество кода.

---

## 3. Краткая карта: Проблема → Изменение → Обоснование

- **Хардкод конфигурации** → Вынести в `@nestjs/config` + схема валидации → Надёжность окружений, безопасность.
- **Побочные эффекты в конструкторах** → Перенос в `onModuleInit`/lifecycle и `await` → Предсказуемая инициализация.
- **Kafka без await и ретраев** → `await send` + обработка ошибок/ретраи → Гарантированная отправка/видимость сбоев.
- **`decimal` как `number`** → Строка/BigNumber/трансформер → Корректные сравнения и отсутствие лишних апдейтов.
- **Денормализация и несогласованные имена** → Нормализация + единый стиль имён → Целостность и сопровождаемость.
- **Async в `setInterval` без шторки** → `@nestjs/schedule` + защита от конкурентного запуска → Стабильность фоновых задач.
- **Отсутствие глобальной валидации/health** → `ValidationPipe`, health-check → Операбельность, безопасность.
- **Нестрогий TS** → Включить strict-флаги → Раннее обнаружение ошибок.

---

## 4. Приоритеты внедрения
1) Безопасность и надёжность: конфигурация, корректная инициализация Kafka, строгий TS.
2) Корректность домена: приведение `price` к безопасному типу, устранение дублирования полей.
3) Операционные аспекты: health-check, валидация конфигурации, structured logging.
4) Производительность и масштабирование: шедулер, батчи/параллелизм с лимитами.

---

## 5. Потенциальные риски и миграции
- Нормализация сущности потребует миграций БД и возможной адаптации потребителей Kafka.
- Изменение представления `price` потребует адаптации мест, где ожидается `number`.
- Вынесение сидера из `onModuleInit` изменит стартовый сценарий — потребуется обновление README/скриптов.
