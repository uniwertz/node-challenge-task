name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/token-price-service

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: tokens_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      kafka:
        image: confluentinc/cp-kafka:7.3.0
        env:
          KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
          KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
        ports:
          - 9092:9092

    steps:
    - name: Checkout code
      run: |
        git clone https://github.com/${{ github.repository }}.git .
        git checkout ${{ github.sha }}

    - name: Setup Node.js
      run: |
        curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
        sudo apt-get install -y nodejs

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run tests
      run: npm run test
      env:
        NODE_ENV: test
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/tokens_test
        KAFKA_BROKERS: localhost:9092

    - name: Run e2e tests
      run: npm run test:e2e
      env:
        NODE_ENV: test
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/tokens_test
        KAFKA_BROKERS: localhost:9092

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'

    permissions:
      contents: read
      packages: write

    outputs:
      image: ${{ steps.image.outputs.image }}

    steps:
    - name: Checkout code
      run: |
        git clone https://github.com/${{ github.repository }}.git .
        git checkout ${{ github.sha }}

    - name: Set up Docker Buildx
      run: |
        docker buildx create --use
        docker buildx inspect --bootstrap

    - name: Log in to Container Registry
      run: |
        echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

    - name: Extract metadata
      id: meta
      run: |
        # Generate tags based on branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
          TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop"
        else
          TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}"
        fi

        # Add SHA tag
        TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-${{ github.sha }}"

        echo "tags=$TAGS" >> $GITHUB_OUTPUT

    - name: Build and push Docker image
      run: |
        # Build with multiple tags
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          docker buildx build \
            --platform linux/amd64 \
            --file ./Dockerfile \
            --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main" \
            --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" \
            --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main-${{ github.sha }}" \
            --push \
            .
        else
          docker buildx build \
            --platform linux/amd64 \
            --file ./Dockerfile \
            --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}" \
            --tag "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-${{ github.sha }}" \
            --push \
            .
        fi

    - name: Output image
      id: image
      run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}" >> $GITHUB_OUTPUT

  security-scan:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: read
      security-events: write

    steps:
    - name: Install Trivy
      run: |
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy

    - name: Run Trivy vulnerability scanner
      run: |
        trivy image --format sarif --output trivy-results.sarif ${{ needs.build.outputs.image }}

    - name: Upload Trivy scan results to GitHub Security tab
      run: |
        # This would need to be implemented with GitHub API calls
        echo "Security scan completed. Results saved to trivy-results.sarif"

  deploy-staging:
    needs: [build, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout code
      run: |
        git clone https://github.com/${{ github.repository }}.git .
        git checkout ${{ github.sha }}

    - name: Setup kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to staging
      run: |
        export KUBECONFIG=kubeconfig
        kubectl set image deployment/token-price-service token-price-service=${{ needs.build.outputs.image }} -n token-price-service-dev
        kubectl rollout status deployment/token-price-service -n token-price-service-dev --timeout=300s

  deploy-production:
    needs: [build, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - name: Checkout code
      run: |
        git clone https://github.com/${{ github.repository }}.git .
        git checkout ${{ github.sha }}

    - name: Setup kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to production
      run: |
        export KUBECONFIG=kubeconfig
        kubectl set image deployment/token-price-service token-price-service=${{ needs.build.outputs.image }} -n token-price-service
        kubectl rollout status deployment/token-price-service -n token-price-service --timeout=300s

    - name: Run smoke tests
      run: |
        export KUBECONFIG=kubeconfig
        kubectl wait --for=condition=ready pod -l app=token-price-service -n token-price-service --timeout=300s
        # Add actual smoke tests here

  notify:
    needs: [deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Notify deployment status
      run: |
        if [ -n "${{ secrets.SLACK_WEBHOOK }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"Deployment ${{ job.status }} for ${{ github.repository }}\"}" \
            ${{ secrets.SLACK_WEBHOOK }}
        fi
